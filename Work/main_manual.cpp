#include <iostream>
#include <random>

#include "timer.hpp"
#include "utils/utils.hpp"
#include "io/mm.hpp"
#include "matrix/spmat.hpp"
#include "matrix/trimat/spmat.hpp"
#include "blas/blas1.hpp"
#include "solver/gmres.hpp"
#include "solver/irsolver.hpp"
#include "preconditioner/INTAMG.hpp"
#include "smoother/stationary.hpp"

// Namespace of our own library.
using namespace senk;

// Enum for selecting the used smoother
enum class E_Smoother {
    IS_SOR,
    IS_HYBRID_GS,
};

// The value of theta of the classical AMG method.
#define AMG_THETA 0.8

int main(int argc, char **argv) {
    if(argc != 4) return 1;
    /**
     * Reading a matrix of the Matrix Market format and
     * Storing the read matrix in the CSR format.
     **/
    std::string path = "../matrix/";
    path += (argv[1]);
    const char *filename = path.c_str();
    CSRMat *Abase = io::ReadMM(filename, true, false);

    E_Smoother smoother_type = static_cast<E_Smoother>(atoi(argv[2]));
    int res_period = atoi(argv[3]);

    int N = Abase->N;

    /**
     * Setting the right-hand side vector.
     * The vector elements are generated by the Mersenne Twister.
     **/
    double *b = utils::SafeMalloc<double>(N);
    std::mt19937_64 engine(0);
    std::uniform_real_distribution<double> dist(0, 1);
    for(int i=0; i<N; i++) { b[i] = dist(engine); }

    // Initial scaling
    Abase->LMax1Scaling(b);

    double nrm_b = blas1::Nrm2<double>(b, N);

    auto timer = new Timer();

    /** 
     * Generate a coefficient matrix used for SpMV.
     **/
    auto dA = new CSR<double>(Abase);
    
    const int max = 1000;
    const int m = res_period;
    const int outer = max / m;
    const double epsilon = 1.0e-10;
    double *x = utils::SafeMalloc<double>(N);

    /**
     * Constructing a preconditioner and 
     * executing a solver.
     **/
    auto sor_param = new SORParam(1.0, 1);
    auto hybrid_param = new BlockSORParam(1.0, 1, 40);

    auto iA = new CSR<Fixed<30>>(Abase);
    Preconditioner<int> *iM;
    if(smoother_type == E_Smoother::IS_SOR) {
        iM = new intAMGflex<CSRflex, CSRflex, SOR<ldtri::CSRflex, CSRflex>>(
            Abase, iA, new AMGParam(20, AMG_THETA, 1, sor_param));
    }else {
        iM = new intAMGflex<CSRflex, CSRflex, BlockSORflex<ldtri::BJCSRflex, CSRflex>>(
            Abase, iA, new AMGParam(20, AMG_THETA, 1, hybrid_param));
    }
    double *r = senk::utils::SafeMalloc<double>(N);

    // Constructing the solver and solving the problem.
    for(int8_t bit = 20; bit <= 30; bit++) {
        auto i_inner = new FGMRESflex(iA, m, epsilon, iM, bit);
        auto i_solver = new Restarted(dA, i_inner, outer, epsilon);
        utils::Set<double>(0, x, N);
        timer->Restart();
        auto i_converge = i_solver->Solve(b, nrm_b, x);
        timer->Elapsed();
        printf("[Iter] : %d\n", i_converge.iter);
        // Checking the explicit relative residual norm.
        dA->SpMV(x, r);
        senk::blas1::Axpby<double>(1, b, -1, r, N);
        double nrm_r = senk::blas1::Nrm2<double>(r, N);
        printf("# [Res] : %e\n", nrm_r/nrm_b);
        delete i_inner;
        delete i_solver;
        printf("\n");
    }

    return 0;
}
